{"version":3,"file":"chunks/vendors-node_modules_u2f-api_dist_index_js.xxxxxxxxxxxxxxxxxxxx.js","mappings":"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","sources":["webpack:///../node_modules/u2f-api/dist/index.js","webpack:///../node_modules/u2f-api/dist/lib/generated-google-u2f-api.js","webpack:///../node_modules/u2f-api/dist/lib/u2f-api.js"],"sourcesContent":["'use strict';\nfunction __export(m) {\n    for (var p in m) if (!exports.hasOwnProperty(p)) exports[p] = m[p];\n}\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar u2fApi = require(\"./lib/u2f-api\");\n__export(require(\"./lib/u2f-api\"));\nexports.default = u2fApi;\n//# sourceMappingURL=index.js.map","//Copyright 2014-2015 Google Inc. All rights reserved.\n\n//Use of this source code is governed by a BSD-style\n//license that can be found in the LICENSE file or at\n//https://developers.google.com/open-source/licenses/bsd\n\n/**\n * @fileoverview The U2F api.\n */\n'use strict';\n\n\n/**\n * Namespace for the U2F api.\n * @type {Object}\n */\nvar u2f = u2f || {};\n\nmodule.exports = u2f; // Adaptation for u2f-api package\n\n/**\n * FIDO U2F Javascript API Version\n * @number\n */\nvar js_api_version;\n\n/**\n * The U2F extension id\n * @const {string}\n */\n// The Chrome packaged app extension ID.\n// Uncomment this if you want to deploy a server instance that uses\n// the package Chrome app and does not require installing the U2F Chrome extension.\n u2f.EXTENSION_ID = 'kmendfapggjehodndflmmgagdbamhnfd';\n// The U2F Chrome extension ID.\n// Uncomment this if you want to deploy a server instance that uses\n// the U2F Chrome extension to authenticate.\n// u2f.EXTENSION_ID = 'pfboblefjcgdjicmnffhdgionmgcdmne';\n\n\n/**\n * Message types for messsages to/from the extension\n * @const\n * @enum {string}\n */\nu2f.MessageTypes = {\n    'U2F_REGISTER_REQUEST': 'u2f_register_request',\n    'U2F_REGISTER_RESPONSE': 'u2f_register_response',\n    'U2F_SIGN_REQUEST': 'u2f_sign_request',\n    'U2F_SIGN_RESPONSE': 'u2f_sign_response',\n    'U2F_GET_API_VERSION_REQUEST': 'u2f_get_api_version_request',\n    'U2F_GET_API_VERSION_RESPONSE': 'u2f_get_api_version_response'\n};\n\n\n/**\n * Response status codes\n * @const\n * @enum {number}\n */\nu2f.ErrorCodes = {\n    'OK': 0,\n    'OTHER_ERROR': 1,\n    'BAD_REQUEST': 2,\n    'CONFIGURATION_UNSUPPORTED': 3,\n    'DEVICE_INELIGIBLE': 4,\n    'TIMEOUT': 5\n};\n\n\n/**\n * A message for registration requests\n * @typedef {{\n *   type: u2f.MessageTypes,\n *   appId: ?string,\n *   timeoutSeconds: ?number,\n *   requestId: ?number\n * }}\n */\nu2f.U2fRequest;\n\n\n/**\n * A message for registration responses\n * @typedef {{\n *   type: u2f.MessageTypes,\n *   responseData: (u2f.Error | u2f.RegisterResponse | u2f.SignResponse),\n *   requestId: ?number\n * }}\n */\nu2f.U2fResponse;\n\n\n/**\n * An error object for responses\n * @typedef {{\n *   errorCode: u2f.ErrorCodes,\n *   errorMessage: ?string\n * }}\n */\nu2f.Error;\n\n/**\n * Data object for a single sign request.\n * @typedef {enum {BLUETOOTH_RADIO, BLUETOOTH_LOW_ENERGY, USB, NFC, USB_INTERNAL}}\n */\nu2f.Transport;\n\n\n/**\n * Data object for a single sign request.\n * @typedef {Array<u2f.Transport>}\n */\nu2f.Transports;\n\n/**\n * Data object for a single sign request.\n * @typedef {{\n *   version: string,\n *   challenge: string,\n *   keyHandle: string,\n *   appId: string\n * }}\n */\nu2f.SignRequest;\n\n\n/**\n * Data object for a sign response.\n * @typedef {{\n *   keyHandle: string,\n *   signatureData: string,\n *   clientData: string\n * }}\n */\nu2f.SignResponse;\n\n\n/**\n * Data object for a registration request.\n * @typedef {{\n *   version: string,\n *   challenge: string\n * }}\n */\nu2f.RegisterRequest;\n\n\n/**\n * Data object for a registration response.\n * @typedef {{\n *   version: string,\n *   keyHandle: string,\n *   transports: Transports,\n *   appId: string\n * }}\n */\nu2f.RegisterResponse;\n\n\n/**\n * Data object for a registered key.\n * @typedef {{\n *   version: string,\n *   keyHandle: string,\n *   transports: ?Transports,\n *   appId: ?string\n * }}\n */\nu2f.RegisteredKey;\n\n\n/**\n * Data object for a get API register response.\n * @typedef {{\n *   js_api_version: number\n * }}\n */\nu2f.GetJsApiVersionResponse;\n\n\n//Low level MessagePort API support\n\n/**\n * Sets up a MessagePort to the U2F extension using the\n * available mechanisms.\n * @param {function((MessagePort|u2f.WrappedChromeRuntimePort_))} callback\n */\nu2f.getMessagePort = function(callback) {\n  if (typeof chrome != 'undefined' && chrome.runtime) {\n    // The actual message here does not matter, but we need to get a reply\n    // for the callback to run. Thus, send an empty signature request\n    // in order to get a failure response.\n    var msg = {\n        type: u2f.MessageTypes.U2F_SIGN_REQUEST,\n        signRequests: []\n    };\n    chrome.runtime.sendMessage(u2f.EXTENSION_ID, msg, function() {\n      if (!chrome.runtime.lastError) {\n        // We are on a whitelisted origin and can talk directly\n        // with the extension.\n        u2f.getChromeRuntimePort_(callback);\n      } else {\n        // chrome.runtime was available, but we couldn't message\n        // the extension directly, use iframe\n        u2f.getIframePort_(callback);\n      }\n    });\n  } else if (u2f.isAndroidChrome_()) {\n    u2f.getAuthenticatorPort_(callback);\n  } else if (u2f.isIosChrome_()) {\n    u2f.getIosPort_(callback);\n  } else {\n    // chrome.runtime was not available at all, which is normal\n    // when this origin doesn't have access to any extensions.\n    u2f.getIframePort_(callback);\n  }\n};\n\n/**\n * Detect chrome running on android based on the browser's useragent.\n * @private\n */\nu2f.isAndroidChrome_ = function() {\n  var userAgent = navigator.userAgent;\n  return userAgent.indexOf('Chrome') != -1 &&\n  userAgent.indexOf('Android') != -1;\n};\n\n/**\n * Detect chrome running on iOS based on the browser's platform.\n * @private\n */\nu2f.isIosChrome_ = function() {\n  return [\"iPhone\", \"iPad\", \"iPod\"].indexOf(navigator.platform) > -1;\n};\n\n/**\n * Connects directly to the extension via chrome.runtime.connect.\n * @param {function(u2f.WrappedChromeRuntimePort_)} callback\n * @private\n */\nu2f.getChromeRuntimePort_ = function(callback) {\n  var port = chrome.runtime.connect(u2f.EXTENSION_ID,\n      {'includeTlsChannelId': true});\n  setTimeout(function() {\n    callback(new u2f.WrappedChromeRuntimePort_(port));\n  }, 0);\n};\n\n/**\n * Return a 'port' abstraction to the Authenticator app.\n * @param {function(u2f.WrappedAuthenticatorPort_)} callback\n * @private\n */\nu2f.getAuthenticatorPort_ = function(callback) {\n  setTimeout(function() {\n    callback(new u2f.WrappedAuthenticatorPort_());\n  }, 0);\n};\n\n/**\n * Return a 'port' abstraction to the iOS client app.\n * @param {function(u2f.WrappedIosPort_)} callback\n * @private\n */\nu2f.getIosPort_ = function(callback) {\n  setTimeout(function() {\n    callback(new u2f.WrappedIosPort_());\n  }, 0);\n};\n\n/**\n * A wrapper for chrome.runtime.Port that is compatible with MessagePort.\n * @param {Port} port\n * @constructor\n * @private\n */\nu2f.WrappedChromeRuntimePort_ = function(port) {\n  this.port_ = port;\n};\n\n/**\n * Format and return a sign request compliant with the JS API version supported by the extension.\n * @param {Array<u2f.SignRequest>} signRequests\n * @param {number} timeoutSeconds\n * @param {number} reqId\n * @return {Object}\n */\nu2f.formatSignRequest_ =\n  function(appId, challenge, registeredKeys, timeoutSeconds, reqId) {\n  if (js_api_version === undefined || js_api_version < 1.1) {\n    // Adapt request to the 1.0 JS API\n    var signRequests = [];\n    for (var i = 0; i < registeredKeys.length; i++) {\n      signRequests[i] = {\n          version: registeredKeys[i].version,\n          challenge: challenge,\n          keyHandle: registeredKeys[i].keyHandle,\n          appId: appId\n      };\n    }\n    return {\n      type: u2f.MessageTypes.U2F_SIGN_REQUEST,\n      signRequests: signRequests,\n      timeoutSeconds: timeoutSeconds,\n      requestId: reqId\n    };\n  }\n  // JS 1.1 API\n  return {\n    type: u2f.MessageTypes.U2F_SIGN_REQUEST,\n    appId: appId,\n    challenge: challenge,\n    registeredKeys: registeredKeys,\n    timeoutSeconds: timeoutSeconds,\n    requestId: reqId\n  };\n};\n\n/**\n * Format and return a register request compliant with the JS API version supported by the extension..\n * @param {Array<u2f.SignRequest>} signRequests\n * @param {Array<u2f.RegisterRequest>} signRequests\n * @param {number} timeoutSeconds\n * @param {number} reqId\n * @return {Object}\n */\nu2f.formatRegisterRequest_ =\n  function(appId, registeredKeys, registerRequests, timeoutSeconds, reqId) {\n  if (js_api_version === undefined || js_api_version < 1.1) {\n    // Adapt request to the 1.0 JS API\n    for (var i = 0; i < registerRequests.length; i++) {\n      registerRequests[i].appId = appId;\n    }\n    var signRequests = [];\n    for (var i = 0; i < registeredKeys.length; i++) {\n      signRequests[i] = {\n          version: registeredKeys[i].version,\n          challenge: registerRequests[0],\n          keyHandle: registeredKeys[i].keyHandle,\n          appId: appId\n      };\n    }\n    return {\n      type: u2f.MessageTypes.U2F_REGISTER_REQUEST,\n      signRequests: signRequests,\n      registerRequests: registerRequests,\n      timeoutSeconds: timeoutSeconds,\n      requestId: reqId\n    };\n  }\n  // JS 1.1 API\n  return {\n    type: u2f.MessageTypes.U2F_REGISTER_REQUEST,\n    appId: appId,\n    registerRequests: registerRequests,\n    registeredKeys: registeredKeys,\n    timeoutSeconds: timeoutSeconds,\n    requestId: reqId\n  };\n};\n\n\n/**\n * Posts a message on the underlying channel.\n * @param {Object} message\n */\nu2f.WrappedChromeRuntimePort_.prototype.postMessage = function(message) {\n  this.port_.postMessage(message);\n};\n\n\n/**\n * Emulates the HTML 5 addEventListener interface. Works only for the\n * onmessage event, which is hooked up to the chrome.runtime.Port.onMessage.\n * @param {string} eventName\n * @param {function({data: Object})} handler\n */\nu2f.WrappedChromeRuntimePort_.prototype.addEventListener =\n    function(eventName, handler) {\n  var name = eventName.toLowerCase();\n  if (name == 'message' || name == 'onmessage') {\n    this.port_.onMessage.addListener(function(message) {\n      // Emulate a minimal MessageEvent object\n      handler({'data': message});\n    });\n  } else {\n    console.error('WrappedChromeRuntimePort only supports onMessage');\n  }\n};\n\n/**\n * Wrap the Authenticator app with a MessagePort interface.\n * @constructor\n * @private\n */\nu2f.WrappedAuthenticatorPort_ = function() {\n  this.requestId_ = -1;\n  this.requestObject_ = null;\n}\n\n/**\n * Launch the Authenticator intent.\n * @param {Object} message\n */\nu2f.WrappedAuthenticatorPort_.prototype.postMessage = function(message) {\n  var intentUrl =\n    u2f.WrappedAuthenticatorPort_.INTENT_URL_BASE_ +\n    ';S.request=' + encodeURIComponent(JSON.stringify(message)) +\n    ';end';\n  document.location = intentUrl;\n};\n\n/**\n * Tells what type of port this is.\n * @return {String} port type\n */\nu2f.WrappedAuthenticatorPort_.prototype.getPortType = function() {\n  return \"WrappedAuthenticatorPort_\";\n};\n\n\n/**\n * Emulates the HTML 5 addEventListener interface.\n * @param {string} eventName\n * @param {function({data: Object})} handler\n */\nu2f.WrappedAuthenticatorPort_.prototype.addEventListener = function(eventName, handler) {\n  var name = eventName.toLowerCase();\n  if (name == 'message') {\n    var self = this;\n    /* Register a callback to that executes when\n     * chrome injects the response. */\n    window.addEventListener(\n        'message', self.onRequestUpdate_.bind(self, handler), false);\n  } else {\n    console.error('WrappedAuthenticatorPort only supports message');\n  }\n};\n\n/**\n * Callback invoked  when a response is received from the Authenticator.\n * @param function({data: Object}) callback\n * @param {Object} message message Object\n */\nu2f.WrappedAuthenticatorPort_.prototype.onRequestUpdate_ =\n    function(callback, message) {\n  var messageObject = JSON.parse(message.data);\n  var intentUrl = messageObject['intentURL'];\n\n  var errorCode = messageObject['errorCode'];\n  var responseObject = null;\n  if (messageObject.hasOwnProperty('data')) {\n    responseObject = /** @type {Object} */ (\n        JSON.parse(messageObject['data']));\n  }\n\n  callback({'data': responseObject});\n};\n\n/**\n * Base URL for intents to Authenticator.\n * @const\n * @private\n */\nu2f.WrappedAuthenticatorPort_.INTENT_URL_BASE_ =\n  'intent:#Intent;action=com.google.android.apps.authenticator.AUTHENTICATE';\n\n/**\n * Wrap the iOS client app with a MessagePort interface.\n * @constructor\n * @private\n */\nu2f.WrappedIosPort_ = function() {};\n\n/**\n * Launch the iOS client app request\n * @param {Object} message\n */\nu2f.WrappedIosPort_.prototype.postMessage = function(message) {\n  var str = JSON.stringify(message);\n  var url = \"u2f://auth?\" + encodeURI(str);\n  location.replace(url);\n};\n\n/**\n * Tells what type of port this is.\n * @return {String} port type\n */\nu2f.WrappedIosPort_.prototype.getPortType = function() {\n  return \"WrappedIosPort_\";\n};\n\n/**\n * Emulates the HTML 5 addEventListener interface.\n * @param {string} eventName\n * @param {function({data: Object})} handler\n */\nu2f.WrappedIosPort_.prototype.addEventListener = function(eventName, handler) {\n  var name = eventName.toLowerCase();\n  if (name !== 'message') {\n    console.error('WrappedIosPort only supports message');\n  }\n};\n\n/**\n * Sets up an embedded trampoline iframe, sourced from the extension.\n * @param {function(MessagePort)} callback\n * @private\n */\nu2f.getIframePort_ = function(callback) {\n  // Create the iframe\n  var iframeOrigin = 'chrome-extension://' + u2f.EXTENSION_ID;\n  var iframe = document.createElement('iframe');\n  iframe.src = iframeOrigin + '/u2f-comms.html';\n  iframe.setAttribute('style', 'display:none');\n  document.body.appendChild(iframe);\n\n  var channel = new MessageChannel();\n  var ready = function(message) {\n    if (message.data == 'ready') {\n      channel.port1.removeEventListener('message', ready);\n      callback(channel.port1);\n    } else {\n      console.error('First event on iframe port was not \"ready\"');\n    }\n  };\n  channel.port1.addEventListener('message', ready);\n  channel.port1.start();\n\n  iframe.addEventListener('load', function() {\n    // Deliver the port to the iframe and initialize\n    iframe.contentWindow.postMessage('init', iframeOrigin, [channel.port2]);\n  });\n};\n\n\n//High-level JS API\n\n/**\n * Default extension response timeout in seconds.\n * @const\n */\nu2f.EXTENSION_TIMEOUT_SEC = 30;\n\n/**\n * A singleton instance for a MessagePort to the extension.\n * @type {MessagePort|u2f.WrappedChromeRuntimePort_}\n * @private\n */\nu2f.port_ = null;\n\n/**\n * Callbacks waiting for a port\n * @type {Array<function((MessagePort|u2f.WrappedChromeRuntimePort_))>}\n * @private\n */\nu2f.waitingForPort_ = [];\n\n/**\n * A counter for requestIds.\n * @type {number}\n * @private\n */\nu2f.reqCounter_ = 0;\n\n/**\n * A map from requestIds to client callbacks\n * @type {Object.<number,(function((u2f.Error|u2f.RegisterResponse))\n *                       |function((u2f.Error|u2f.SignResponse)))>}\n * @private\n */\nu2f.callbackMap_ = {};\n\n/**\n * Creates or retrieves the MessagePort singleton to use.\n * @param {function((MessagePort|u2f.WrappedChromeRuntimePort_))} callback\n * @private\n */\nu2f.getPortSingleton_ = function(callback) {\n  if (u2f.port_) {\n    callback(u2f.port_);\n  } else {\n    if (u2f.waitingForPort_.length == 0) {\n      u2f.getMessagePort(function(port) {\n        u2f.port_ = port;\n        u2f.port_.addEventListener('message',\n            /** @type {function(Event)} */ (u2f.responseHandler_));\n\n        // Careful, here be async callbacks. Maybe.\n        while (u2f.waitingForPort_.length)\n          u2f.waitingForPort_.shift()(u2f.port_);\n      });\n    }\n    u2f.waitingForPort_.push(callback);\n  }\n};\n\n/**\n * Handles response messages from the extension.\n * @param {MessageEvent.<u2f.Response>} message\n * @private\n */\nu2f.responseHandler_ = function(message) {\n  var response = message.data;\n  var reqId = response['requestId'];\n  if (!reqId || !u2f.callbackMap_[reqId]) {\n    console.error('Unknown or missing requestId in response.');\n    return;\n  }\n  var cb = u2f.callbackMap_[reqId];\n  delete u2f.callbackMap_[reqId];\n  cb(response['responseData']);\n};\n\n/**\n * Calls the callback with true or false as first and only argument\n * @param {Function} callback\n */\nu2f.isSupported = function(callback) {\n  var hasCalledBack = false;\n  function reply(value) {\n    if (hasCalledBack)\n      return;\n    hasCalledBack = true;\n    callback(value);\n  }\n  u2f.getApiVersion(\n    function (response) {\n      js_api_version = response['js_api_version'] === undefined ? 0 : response['js_api_version'];\n      reply(true);\n    }\n  );\n  // No response from extension within 1500ms -> no support\n  setTimeout(reply.bind(null, false), 1500);\n};\n\n/**\n * Dispatches an array of sign requests to available U2F tokens.\n * If the JS API version supported by the extension is unknown, it first sends a\n * message to the extension to find out the supported API version and then it sends\n * the sign request.\n * @param {string=} appId\n * @param {string=} challenge\n * @param {Array<u2f.RegisteredKey>} registeredKeys\n * @param {function((u2f.Error|u2f.SignResponse))} callback\n * @param {number=} opt_timeoutSeconds\n */\nu2f.sign = function(appId, challenge, registeredKeys, callback, opt_timeoutSeconds) {\n  if (js_api_version === undefined) {\n    // Send a message to get the extension to JS API version, then send the actual sign request.\n    u2f.getApiVersion(\n        function (response) {\n          js_api_version = response['js_api_version'] === undefined ? 0 : response['js_api_version'];\n          console.log(\"Extension JS API Version: \", js_api_version);\n          u2f.sendSignRequest(appId, challenge, registeredKeys, callback, opt_timeoutSeconds);\n        });\n  } else {\n    // We know the JS API version. Send the actual sign request in the supported API version.\n    u2f.sendSignRequest(appId, challenge, registeredKeys, callback, opt_timeoutSeconds);\n  }\n};\n\n/**\n * Dispatches an array of sign requests to available U2F tokens.\n * @param {string=} appId\n * @param {string=} challenge\n * @param {Array<u2f.RegisteredKey>} registeredKeys\n * @param {function((u2f.Error|u2f.SignResponse))} callback\n * @param {number=} opt_timeoutSeconds\n */\nu2f.sendSignRequest = function(appId, challenge, registeredKeys, callback, opt_timeoutSeconds) {\n  u2f.getPortSingleton_(function(port) {\n    var reqId = ++u2f.reqCounter_;\n    u2f.callbackMap_[reqId] = callback;\n    var timeoutSeconds = (typeof opt_timeoutSeconds !== 'undefined' ?\n        opt_timeoutSeconds : u2f.EXTENSION_TIMEOUT_SEC);\n    var req = u2f.formatSignRequest_(appId, challenge, registeredKeys, timeoutSeconds, reqId);\n    port.postMessage(req);\n  });\n};\n\n/**\n * Dispatches register requests to available U2F tokens. An array of sign\n * requests identifies already registered tokens.\n * If the JS API version supported by the extension is unknown, it first sends a\n * message to the extension to find out the supported API version and then it sends\n * the register request.\n * @param {string=} appId\n * @param {Array<u2f.RegisterRequest>} registerRequests\n * @param {Array<u2f.RegisteredKey>} registeredKeys\n * @param {function((u2f.Error|u2f.RegisterResponse))} callback\n * @param {number=} opt_timeoutSeconds\n */\nu2f.register = function(appId, registerRequests, registeredKeys, callback, opt_timeoutSeconds) {\n  if (js_api_version === undefined) {\n    // Send a message to get the extension to JS API version, then send the actual register request.\n    u2f.getApiVersion(\n        function (response) {\n          js_api_version = response['js_api_version'] === undefined ? 0: response['js_api_version'];\n          console.log(\"Extension JS API Version: \", js_api_version);\n          u2f.sendRegisterRequest(appId, registerRequests, registeredKeys,\n              callback, opt_timeoutSeconds);\n        });\n  } else {\n    // We know the JS API version. Send the actual register request in the supported API version.\n    u2f.sendRegisterRequest(appId, registerRequests, registeredKeys,\n        callback, opt_timeoutSeconds);\n  }\n};\n\n/**\n * Dispatches register requests to available U2F tokens. An array of sign\n * requests identifies already registered tokens.\n * @param {string=} appId\n * @param {Array<u2f.RegisterRequest>} registerRequests\n * @param {Array<u2f.RegisteredKey>} registeredKeys\n * @param {function((u2f.Error|u2f.RegisterResponse))} callback\n * @param {number=} opt_timeoutSeconds\n */\nu2f.sendRegisterRequest = function(appId, registerRequests, registeredKeys, callback, opt_timeoutSeconds) {\n  u2f.getPortSingleton_(function(port) {\n    var reqId = ++u2f.reqCounter_;\n    u2f.callbackMap_[reqId] = callback;\n    var timeoutSeconds = (typeof opt_timeoutSeconds !== 'undefined' ?\n        opt_timeoutSeconds : u2f.EXTENSION_TIMEOUT_SEC);\n    var req = u2f.formatRegisterRequest_(\n        appId, registeredKeys, registerRequests, timeoutSeconds, reqId);\n    port.postMessage(req);\n  });\n};\n\n\n/**\n * Dispatches a message to the extension to find out the supported\n * JS API version.\n * If the user is on a mobile phone and is thus using Google Authenticator instead\n * of the Chrome extension, don't send the request and simply return 0.\n * @param {function((u2f.Error|u2f.GetJsApiVersionResponse))} callback\n * @param {number=} opt_timeoutSeconds\n */\nu2f.getApiVersion = function(callback, opt_timeoutSeconds) {\n u2f.getPortSingleton_(function(port) {\n   // If we are using Android Google Authenticator or iOS client app,\n   // do not fire an intent to ask which JS API version to use.\n   if (port.getPortType) {\n     var apiVersion;\n     switch (port.getPortType()) {\n       case 'WrappedIosPort_':\n       case 'WrappedAuthenticatorPort_':\n         apiVersion = 1.1;\n         break;\n\n       default:\n         apiVersion = 0;\n         break;\n     }\n     callback({ 'js_api_version': apiVersion });\n     return;\n   }\n    var reqId = ++u2f.reqCounter_;\n    u2f.callbackMap_[reqId] = callback;\n    var req = {\n      type: u2f.MessageTypes.U2F_GET_API_VERSION_REQUEST,\n      timeoutSeconds: (typeof opt_timeoutSeconds !== 'undefined' ?\n          opt_timeoutSeconds : u2f.EXTENSION_TIMEOUT_SEC),\n      requestId: reqId\n    };\n    port.postMessage(req);\n  });\n};\n","'use strict';\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar chromeApi = require(\"./generated-google-u2f-api\");\n// Feature detection (yes really)\nvar isBrowser = (typeof navigator !== 'undefined') && !!navigator.userAgent;\nvar isSafari = isBrowser && navigator.userAgent.match(/Safari\\//)\n    && !navigator.userAgent.match(/Chrome\\//);\nvar isEDGE = isBrowser && navigator.userAgent.match(/Edge\\/1[2345]/);\nvar _backend = null;\nfunction getBackend() {\n    if (_backend)\n        return _backend;\n    var supportChecker = new Promise(function (resolve, reject) {\n        function notSupported() {\n            resolve({ u2f: null });\n        }\n        if (!isBrowser)\n            return notSupported();\n        if (isSafari)\n            // Safari doesn't support U2F, and the Safari-FIDO-U2F\n            // extension lacks full support (Multi-facet apps), so we\n            // block it until proper support.\n            return notSupported();\n        var hasNativeSupport = (typeof window.u2f !== 'undefined') &&\n            (typeof window.u2f.sign === 'function');\n        if (hasNativeSupport)\n            return resolve({ u2f: window.u2f });\n        if (isEDGE)\n            // We don't want to check for Google's extension hack on EDGE\n            // as it'll cause trouble (popups, etc)\n            return notSupported();\n        if (location.protocol === 'http:')\n            // U2F isn't supported over http, only https\n            return notSupported();\n        if (typeof MessageChannel === 'undefined')\n            // Unsupported browser, the chrome hack would throw\n            return notSupported();\n        // Test for google extension support\n        chromeApi.isSupported(function (ok) {\n            if (ok)\n                resolve({ u2f: chromeApi });\n            else\n                notSupported();\n        });\n    })\n        .then(function (response) {\n        _backend = response.u2f ? supportChecker : null;\n        return response;\n    });\n    return supportChecker;\n}\nexports.ErrorCodes = {\n    OK: 0,\n    OTHER_ERROR: 1,\n    BAD_REQUEST: 2,\n    CONFIGURATION_UNSUPPORTED: 3,\n    DEVICE_INELIGIBLE: 4,\n    TIMEOUT: 5\n};\nexports.ErrorNames = {\n    \"0\": \"OK\",\n    \"1\": \"OTHER_ERROR\",\n    \"2\": \"BAD_REQUEST\",\n    \"3\": \"CONFIGURATION_UNSUPPORTED\",\n    \"4\": \"DEVICE_INELIGIBLE\",\n    \"5\": \"TIMEOUT\"\n};\nfunction makeError(msg, err) {\n    var code = err != null ? err.errorCode : 1; // Default to OTHER_ERROR\n    var type = exports.ErrorNames['' + code];\n    var error = new Error(msg);\n    error.metaData = { type: type, code: code };\n    return error;\n}\nfunction isSupported() {\n    return getBackend()\n        .then(function (backend) { return !!backend.u2f; });\n}\nexports.isSupported = isSupported;\nfunction _ensureSupport(backend) {\n    if (!backend.u2f) {\n        if (location.protocol === 'http:')\n            throw new Error(\"U2F isn't supported over http, only https\");\n        throw new Error(\"U2F not supported\");\n    }\n}\nfunction ensureSupport() {\n    return getBackend()\n        .then(_ensureSupport);\n}\nexports.ensureSupport = ensureSupport;\nfunction arrayify(value) {\n    if (value != null && Array.isArray(value))\n        return value;\n    return value == null\n        ? []\n        : Array.isArray(value)\n            ? value.slice() : [value];\n}\nfunction register(registerRequests, signRequests, timeout) {\n    var _registerRequests = arrayify(registerRequests);\n    if (typeof signRequests === 'number' && typeof timeout === 'undefined') {\n        timeout = signRequests;\n        signRequests = null;\n    }\n    var _signRequests = arrayify(signRequests);\n    return getBackend()\n        .then(function (backend) {\n        _ensureSupport(backend);\n        var u2f = backend.u2f;\n        return new Promise(function (resolve, reject) {\n            function callback(response) {\n                if (response.errorCode)\n                    reject(makeError(\"Registration failed\", response));\n                else {\n                    delete response.errorCode;\n                    resolve(response);\n                }\n            }\n            var appId = _registerRequests[0].appId;\n            u2f.register(appId, _registerRequests, _signRequests, callback, timeout);\n        });\n    });\n}\nexports.register = register;\nfunction sign(signRequests, timeout) {\n    var _signRequests = arrayify(signRequests);\n    return getBackend()\n        .then(function (backend) {\n        _ensureSupport(backend);\n        var u2f = backend.u2f;\n        return new Promise(function (resolve, reject) {\n            function callback(response) {\n                if (response.errorCode)\n                    reject(makeError(\"Sign failed\", response));\n                else {\n                    delete response.errorCode;\n                    resolve(response);\n                }\n            }\n            var appId = _signRequests[0].appId;\n            var challenge = _signRequests[0].challenge;\n            var registeredKeys = _signRequests\n                .map(function (_a) {\n                var version = _a.version, keyHandle = _a.keyHandle, appId = _a.appId;\n                return ({ version: version, keyHandle: keyHandle, appId: appId });\n            });\n            u2f.sign(appId, challenge, registeredKeys, callback, timeout);\n        });\n    });\n}\nexports.sign = sign;\n//# sourceMappingURL=u2f-api.js.map"],"names":["Object","defineProperty","exports","value","u2fApi","m","p","hasOwnProperty","__export","default","js_api_version","u2f","module","EXTENSION_ID","MessageTypes","ErrorCodes","U2fRequest","U2fResponse","Error","Transport","Transports","SignRequest","SignResponse","RegisterRequest","RegisterResponse","RegisteredKey","GetJsApiVersionResponse","getMessagePort","callback","chrome","runtime","msg","type","U2F_SIGN_REQUEST","signRequests","sendMessage","lastError","getIframePort_","getChromeRuntimePort_","isAndroidChrome_","getAuthenticatorPort_","isIosChrome_","getIosPort_","userAgent","navigator","indexOf","platform","port","connect","setTimeout","WrappedChromeRuntimePort_","WrappedAuthenticatorPort_","WrappedIosPort_","this","port_","formatSignRequest_","appId","challenge","registeredKeys","timeoutSeconds","reqId","undefined","i","length","version","keyHandle","requestId","formatRegisterRequest_","registerRequests","U2F_REGISTER_REQUEST","prototype","postMessage","message","addEventListener","eventName","handler","name","toLowerCase","onMessage","addListener","console","error","requestId_","requestObject_","intentUrl","INTENT_URL_BASE_","encodeURIComponent","JSON","stringify","document","location","getPortType","window","onRequestUpdate_","bind","messageObject","parse","data","responseObject","str","url","encodeURI","replace","iframeOrigin","iframe","createElement","src","setAttribute","body","appendChild","channel","MessageChannel","ready","port1","removeEventListener","start","contentWindow","port2","EXTENSION_TIMEOUT_SEC","waitingForPort_","reqCounter_","callbackMap_","getPortSingleton_","shift","push","responseHandler_","response","cb","isSupported","hasCalledBack","reply","getApiVersion","sign","opt_timeoutSeconds","log","sendSignRequest","req","register","sendRegisterRequest","apiVersion","U2F_GET_API_VERSION_REQUEST","chromeApi","isBrowser","isSafari","match","isEDGE","_backend","getBackend","supportChecker","Promise","resolve","reject","notSupported","protocol","ok","then","makeError","err","code","errorCode","ErrorNames","metaData","_ensureSupport","backend","arrayify","Array","isArray","slice","OK","OTHER_ERROR","BAD_REQUEST","CONFIGURATION_UNSUPPORTED","DEVICE_INELIGIBLE","TIMEOUT","ensureSupport","timeout","_registerRequests","_signRequests","map","_a"],"sourceRoot":""}