{"version":3,"file":"chunks/app_views_asyncView_tsx-app_views_settings_components_teamSelect_tsx.xxxxxxxxxxxxxxxxxxxx.js","mappings":"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","sources":["webpack:///./app/actionCreators/teams.tsx","webpack:///./app/utils/isActiveSuperuser.tsx","webpack:///./app/utils/useTeams.tsx","webpack:///./app/views/asyncView.tsx","webpack:///./app/components/idBadge/teamBadge/index.tsx","webpack:///./app/views/settings/components/teamSelect.tsx"],"sourcesContent":["import {addErrorMessage, addSuccessMessage} from 'app/actionCreators/indicator';\nimport TeamActions from 'app/actions/teamActions';\nimport {Client} from 'app/api';\nimport {tct} from 'app/locale';\nimport {Team} from 'app/types';\nimport {callIfFunction} from 'app/utils/callIfFunction';\nimport {uniqueId} from 'app/utils/guid';\n\ntype CallbackOptions = {\n  success?: Function;\n  error?: Function;\n};\n\nconst doCallback = (\n  params: CallbackOptions = {},\n  name: keyof CallbackOptions,\n  ...args: any[]\n) => {\n  callIfFunction(params[name], ...args);\n};\n\n/**\n * Note these are both slugs\n */\ntype OrgSlug = {orgId: string};\ntype OrgAndTeamSlug = OrgSlug & {teamId: string};\n\ntype TeamData = {data: Team};\n\n/**\n * This is the actual internal id, not username or email\n */\ntype MemberId = {memberId: string};\n\n// Fetch teams for org\nexport function fetchTeams(api: Client, params: OrgSlug, options: CallbackOptions) {\n  TeamActions.fetchAll(params.orgId);\n  return api.request(`/teams/${params.orgId}/`, {\n    success: data => {\n      TeamActions.fetchAllSuccess(params.orgId, data);\n      doCallback(options, 'success', data);\n    },\n    error: error => {\n      TeamActions.fetchAllError(params.orgId, error);\n      doCallback(options, 'error', error);\n    },\n  });\n}\n\n// Fetch user teams for current org and place them in the team store\nexport async function fetchUserTeams(api: Client, params: OrgSlug) {\n  const teams = await api.requestPromise(`/organizations/${params.orgId}/user-teams/`);\n  TeamActions.loadUserTeams(teams);\n}\n\nexport function fetchTeamDetails(\n  api: Client,\n  params: OrgAndTeamSlug,\n  options?: CallbackOptions\n) {\n  TeamActions.fetchDetails(params.teamId);\n  return api.request(`/teams/${params.orgId}/${params.teamId}/`, {\n    success: data => {\n      TeamActions.fetchDetailsSuccess(params.teamId, data);\n      doCallback(options, 'success', data);\n    },\n    error: error => {\n      TeamActions.fetchDetailsError(params.teamId, error);\n      doCallback(options, 'error', error);\n    },\n  });\n}\n\nexport function updateTeamSuccess(teamId: OrgAndTeamSlug['teamId'], data: Team) {\n  TeamActions.updateSuccess(teamId, data);\n}\n\nexport function updateTeam(\n  api: Client,\n  params: OrgAndTeamSlug & TeamData,\n  options: CallbackOptions\n) {\n  const endpoint = `/teams/${params.orgId}/${params.teamId}/`;\n  TeamActions.update(params.teamId, params.data);\n\n  return api.request(endpoint, {\n    method: 'PUT',\n    data: params.data,\n    success: data => {\n      updateTeamSuccess(params.teamId, data);\n      doCallback(options, 'success', data);\n    },\n    error: error => {\n      TeamActions.updateError(params.teamId, error);\n      doCallback(options, 'error', error);\n    },\n  });\n}\n\nexport function joinTeam(\n  api: Client,\n  params: OrgAndTeamSlug & Partial<MemberId>,\n  options: CallbackOptions\n) {\n  const endpoint = `/organizations/${params.orgId}/members/${\n    params.memberId ?? 'me'\n  }/teams/${params.teamId}/`;\n  const id = uniqueId();\n\n  TeamActions.update(id, params.teamId);\n\n  return api.request(endpoint, {\n    method: 'POST',\n    success: data => {\n      TeamActions.updateSuccess(params.teamId, data);\n      doCallback(options, 'success', data);\n    },\n    error: error => {\n      TeamActions.updateError(id, params.teamId, error);\n      doCallback(options, 'error', error);\n    },\n  });\n}\n\nexport function leaveTeam(\n  api: Client,\n  params: OrgAndTeamSlug & Partial<MemberId>,\n  options: CallbackOptions\n) {\n  const endpoint = `/organizations/${params.orgId}/members/${\n    params.memberId || 'me'\n  }/teams/${params.teamId}/`;\n  const id = uniqueId();\n\n  TeamActions.update(id, params.teamId);\n\n  return api.request(endpoint, {\n    method: 'DELETE',\n    success: data => {\n      TeamActions.updateSuccess(params.teamId, data);\n      doCallback(options, 'success', data);\n    },\n    error: error => {\n      TeamActions.updateError(id, params.teamId, error);\n      doCallback(options, 'error', error);\n    },\n  });\n}\n\nexport function createTeam(api: Client, team: Pick<Team, 'slug'>, params: OrgSlug) {\n  TeamActions.createTeam(team);\n\n  return api\n    .requestPromise(`/organizations/${params.orgId}/teams/`, {\n      method: 'POST',\n      data: team,\n    })\n    .then(\n      data => {\n        TeamActions.createTeamSuccess(data);\n        addSuccessMessage(\n          tct('[team] has been added to the [organization] organization', {\n            team: `#${data.slug}`,\n            organization: params.orgId,\n          })\n        );\n        return data;\n      },\n      err => {\n        TeamActions.createTeamError(team.slug, err);\n        addErrorMessage(\n          tct('Unable to create [team] in the [organization] organization', {\n            team: `#${team.slug}`,\n            organization: params.orgId,\n          })\n        );\n        throw err;\n      }\n    );\n}\n\nexport function removeTeam(api: Client, params: OrgAndTeamSlug) {\n  TeamActions.removeTeam(params.teamId);\n\n  return api\n    .requestPromise(`/teams/${params.orgId}/${params.teamId}/`, {\n      method: 'DELETE',\n    })\n    .then(\n      data => {\n        TeamActions.removeTeamSuccess(params.teamId, data);\n        addSuccessMessage(\n          tct('[team] has been removed from the [organization] organization', {\n            team: `#${params.teamId}`,\n            organization: params.orgId,\n          })\n        );\n        return data;\n      },\n      err => {\n        TeamActions.removeTeamError(params.teamId, err);\n        addErrorMessage(\n          tct('Unable to remove [team] from the [organization] organization', {\n            team: `#${params.teamId}`,\n            organization: params.orgId,\n          })\n        );\n        throw err;\n      }\n    );\n}\n","import Cookies from 'js-cookie';\n\nimport ConfigStore from 'app/stores/configStore';\n\nconst SUPERUSER_COOKIE_NAME = 'su';\n\n/**\n * Checking for just isSuperuser on a config object may not be enough as backend often checks for *active* superuser.\n * We therefore check both isSuperuser flag AND superuser session cookie.\n */\nexport function isActiveSuperuser() {\n  const {isSuperuser} = ConfigStore.get('user') || {};\n\n  if (isSuperuser) {\n    /**\n     * Superuser cookie cannot be checked for existence as it is HttpOnly.\n     * As a workaround, we try to change it to something else and if that fails we can assume that it's being present.\n     * There may be an edgecase where it's present and expired but for current usage it's not a big deal.\n     */\n    Cookies.set(SUPERUSER_COOKIE_NAME, 'test');\n\n    if (Cookies.get(SUPERUSER_COOKIE_NAME) === undefined) {\n      return true;\n    }\n  }\n\n  return false;\n}\n","import {useEffect, useRef, useState} from 'react';\nimport uniqBy from 'lodash/uniqBy';\n\nimport {fetchUserTeams} from 'app/actionCreators/teams';\nimport TeamActions from 'app/actions/teamActions';\nimport {Client} from 'app/api';\nimport OrganizationStore from 'app/stores/organizationStore';\nimport TeamStore from 'app/stores/teamStore';\nimport {useLegacyStore} from 'app/stores/useLegacyStore';\nimport {Team} from 'app/types';\nimport {isActiveSuperuser} from 'app/utils/isActiveSuperuser';\nimport parseLinkHeader from 'app/utils/parseLinkHeader';\nimport RequestError from 'app/utils/requestError/requestError';\nimport useApi from 'app/utils/useApi';\n\ntype State = {\n  /**\n   * Reflects whether or not the initial fetch for the requested teams was\n   * fulfilled\n   */\n  initiallyLoaded: boolean;\n  /**\n   * This is state for when fetching data from API\n   */\n  fetching: boolean;\n  /**\n   * The error that occurred if fetching failed\n   */\n  fetchError: null | RequestError;\n  /**\n   * Indicates that Team results (from API) are paginated and there are more\n   * Teams that are not in the initial response.\n   */\n  hasMore: null | boolean;\n  /**\n   * The last query we searched. Used to validate the cursor\n   */\n  lastSearch: null | string;\n  /**\n   * Pagination\n   */\n  nextCursor?: null | string;\n};\n\nexport type Result = {\n  /**\n   * The loaded teams list\n   */\n  teams: Team[];\n  /**\n   * This is an action provided to consumers for them to update the current\n   * teams result set using a simple search query.\n   *\n   * Will always add new options into the store.\n   */\n  onSearch: (searchTerm: string) => Promise<void>;\n} & Pick<State, 'fetching' | 'hasMore' | 'fetchError' | 'initiallyLoaded'>;\n\ntype Options = {\n  /**\n   * Number of teams to return when not using `props.slugs`\n   */\n  limit?: number;\n  /**\n   * When provided, fetches specified teams by slug if necessary and only provides those teams.\n   */\n  slugs?: string[];\n  /**\n   * When true, fetches user's teams if necessary and only provides user's\n   * teams (isMember = true).\n   */\n  provideUserTeams?: boolean;\n};\n\ntype FetchTeamOptions = {\n  slugs?: string[];\n  limit?: Options['limit'];\n  cursor?: State['nextCursor'];\n  search?: State['lastSearch'];\n  lastSearch?: State['lastSearch'];\n};\n\n/**\n * Helper function to actually load teams\n */\nasync function fetchTeams(\n  api: Client,\n  orgId: string,\n  {slugs, search, limit, lastSearch, cursor}: FetchTeamOptions = {}\n) {\n  const query: {\n    query?: string;\n    cursor?: typeof cursor;\n    per_page?: number;\n  } = {};\n\n  if (slugs !== undefined && slugs.length > 0) {\n    query.query = slugs.map(slug => `slug:${slug}`).join(' ');\n  }\n\n  if (search) {\n    query.query = `${query.query ?? ''} ${search}`.trim();\n  }\n\n  const isSameSearch = lastSearch === search || (!lastSearch && !search);\n\n  if (isSameSearch && cursor) {\n    query.cursor = cursor;\n  }\n\n  if (limit !== undefined) {\n    query.per_page = limit;\n  }\n\n  let hasMore: null | boolean = false;\n  let nextCursor: null | string = null;\n  const [data, , resp] = await api.requestPromise(`/organizations/${orgId}/teams/`, {\n    includeAllArgs: true,\n    query,\n  });\n\n  const pageLinks = resp?.getResponseHeader('Link');\n  if (pageLinks) {\n    const paginationObject = parseLinkHeader(pageLinks);\n    hasMore = paginationObject?.next?.results || paginationObject?.previous?.results;\n    nextCursor = paginationObject?.next?.cursor;\n  }\n\n  return {results: data, hasMore, nextCursor};\n}\n\n// TODO: Paging for items which have already exist in the store is not\n// correctly implemented.\n\n/**\n * Provides teams from the TeamStore\n *\n * This hook also provides a way to select specific slugs to ensure they are\n * loaded, as well as search (type-ahead) for more slugs that may not be in the\n * TeamsStore.\n *\n * NOTE: It is NOT guaranteed that all teams for an organization will be\n * loaded, so you should use this hook with the intention of providing specific\n * slugs, or loading more through search.\n *\n */\nfunction useTeams({limit, slugs, provideUserTeams}: Options = {}) {\n  const api = useApi();\n  const {organization} = useLegacyStore(OrganizationStore);\n  const store = useLegacyStore(TeamStore);\n\n  const orgId = organization?.slug;\n\n  const storeSlugs = new Set(store.teams.map(t => t.slug));\n  const slugsToLoad = slugs?.filter(slug => !storeSlugs.has(slug)) ?? [];\n  const shouldLoadSlugs = slugsToLoad.length > 0;\n  const shouldLoadTeams = provideUserTeams && !store.loadedUserTeams;\n\n  // If we don't need to make a request either for slugs or user teams, set\n  // initiallyLoaded to true\n  const initiallyLoaded = !shouldLoadSlugs && !shouldLoadTeams;\n\n  const [state, setState] = useState<State>({\n    initiallyLoaded,\n    fetching: false,\n    hasMore: null,\n    lastSearch: null,\n    nextCursor: null,\n    fetchError: null,\n  });\n\n  const slugsRef = useRef<Set<string> | null>(null);\n\n  // Only initialize slugsRef.current once and modify it when we receive new\n  // slugs determined through set equality\n  if (slugs !== undefined) {\n    if (slugsRef.current === null) {\n      slugsRef.current = new Set(slugs);\n    }\n\n    if (\n      slugs.length !== slugsRef.current.size ||\n      slugs.some(slug => !slugsRef.current?.has(slug))\n    ) {\n      slugsRef.current = new Set(slugs);\n    }\n  }\n\n  async function loadUserTeams() {\n    if (orgId === undefined) {\n      return;\n    }\n\n    setState({...state, fetching: true});\n    try {\n      await fetchUserTeams(api, {orgId});\n\n      setState({...state, fetching: false, initiallyLoaded: true});\n    } catch (err) {\n      console.error(err); // eslint-disable-line no-console\n\n      setState({...state, fetching: false, initiallyLoaded: true, fetchError: err});\n    }\n  }\n\n  async function loadTeamsBySlug() {\n    if (orgId === undefined) {\n      return;\n    }\n\n    setState({...state, fetching: true});\n    try {\n      const {results, hasMore, nextCursor} = await fetchTeams(api, orgId, {\n        slugs: slugsToLoad,\n        limit,\n      });\n\n      const fetchedTeams = uniqBy([...store.teams, ...results], ({slug}) => slug);\n      TeamActions.loadTeams(fetchedTeams);\n\n      setState({\n        ...state,\n        hasMore,\n        fetching: false,\n        initiallyLoaded: true,\n        nextCursor,\n      });\n    } catch (err) {\n      console.error(err); // eslint-disable-line no-console\n\n      setState({...state, fetching: false, initiallyLoaded: true, fetchError: err});\n    }\n  }\n\n  async function handleSearch(search: string) {\n    const {lastSearch} = state;\n    const cursor = state.nextCursor;\n\n    if (search === '') {\n      return;\n    }\n\n    if (orgId === undefined) {\n      // eslint-disable-next-line no-console\n      console.error('Cannot use useTeam.onSearch without an organization in context');\n      return;\n    }\n\n    setState({...state, fetching: true});\n\n    try {\n      api.clear();\n      const {results, hasMore, nextCursor} = await fetchTeams(api, orgId, {\n        search,\n        limit,\n        lastSearch,\n        cursor,\n      });\n\n      const fetchedTeams = uniqBy([...store.teams, ...results], ({slug}) => slug);\n\n      // Only update the store if we have more items\n      if (fetchedTeams.length > store.teams.length) {\n        TeamActions.loadTeams(fetchedTeams);\n      }\n\n      setState({\n        ...state,\n        hasMore,\n        fetching: false,\n        lastSearch: search,\n        nextCursor,\n      });\n    } catch (err) {\n      console.error(err); // eslint-disable-line no-console\n\n      setState({...state, fetching: false, fetchError: err});\n    }\n  }\n\n  useEffect(() => {\n    // Load specified team slugs\n    if (shouldLoadSlugs) {\n      loadTeamsBySlug();\n      return;\n    }\n\n    // Load user teams\n    if (shouldLoadTeams) {\n      loadUserTeams();\n    }\n  }, [slugsRef.current, provideUserTeams]);\n\n  const isSuperuser = isActiveSuperuser();\n\n  const filteredTeams = slugs\n    ? store.teams.filter(t => slugs.includes(t.slug))\n    : provideUserTeams && !isSuperuser\n    ? store.teams.filter(t => t.isMember)\n    : store.teams;\n\n  const result: Result = {\n    teams: filteredTeams,\n    fetching: state.fetching || store.loading,\n    initiallyLoaded: state.initiallyLoaded,\n    fetchError: state.fetchError,\n    hasMore: state.hasMore,\n    onSearch: handleSearch,\n  };\n\n  return result;\n}\n\nexport default useTeams;\n","import * as React from 'react';\nimport DocumentTitle from 'react-document-title';\n\nimport AsyncComponent from 'app/components/asyncComponent';\n\ntype AsyncViewState = AsyncComponent['state'];\ntype AsyncViewProps = AsyncComponent['props'];\n\nexport default class AsyncView<\n  P extends AsyncViewProps = AsyncViewProps,\n  S extends AsyncViewState = AsyncViewState\n> extends AsyncComponent<P, S> {\n  getTitle() {\n    return '';\n  }\n\n  render() {\n    const title = this.getTitle();\n    return (\n      <DocumentTitle title={`${title ? `${title} - ` : ''}Sentry`}>\n        {this.renderComponent() as React.ReactChild}\n      </DocumentTitle>\n    );\n  }\n}\n","import * as React from 'react';\nimport isEqual from 'lodash/isEqual';\n\nimport TeamStore from 'app/stores/teamStore';\nimport {Team} from 'app/types';\n\nimport Badge from './badge';\n\ntype Props = React.ComponentProps<typeof Badge>;\n\ntype State = {\n  team: Team;\n};\n\nclass TeamBadgeContainer extends React.Component<Props, State> {\n  state: State = {team: this.props.team};\n\n  UNSAFE_componentWillReceiveProps(nextProps: Props) {\n    if (this.state.team === nextProps.team) {\n      return;\n    }\n\n    if (isEqual(this.state.team, nextProps.team)) {\n      return;\n    }\n\n    this.setState({team: nextProps.team});\n  }\n\n  componentWillUnmount() {\n    this.unlistener?.();\n  }\n\n  unlistener = TeamStore.listen(\n    (team: Set<string>) => this.onTeamStoreUpdate(team),\n    undefined\n  );\n\n  onTeamStoreUpdate(updatedTeam: Set<string>) {\n    if (!updatedTeam.has(this.state.team.id)) {\n      return;\n    }\n\n    const team = TeamStore.getById(this.state.team.id);\n    if (!team || isEqual(team.avatar, this.state.team.avatar)) {\n      return;\n    }\n\n    this.setState({team});\n  }\n\n  render() {\n    return <Badge {...this.props} team={this.state.team} />;\n  }\n}\n\nexport default TeamBadgeContainer;\n","import * as React from 'react';\nimport styled from '@emotion/styled';\nimport debounce from 'lodash/debounce';\n\nimport Button from 'app/components/button';\nimport Confirm from 'app/components/confirm';\nimport DropdownAutoComplete from 'app/components/dropdownAutoComplete';\nimport {Item} from 'app/components/dropdownAutoComplete/types';\nimport DropdownButton from 'app/components/dropdownButton';\nimport TeamBadge from 'app/components/idBadge/teamBadge';\nimport Link from 'app/components/links/link';\nimport LoadingIndicator from 'app/components/loadingIndicator';\nimport {Panel, PanelBody, PanelHeader, PanelItem} from 'app/components/panels';\nimport {DEFAULT_DEBOUNCE_DURATION} from 'app/constants';\nimport {IconSubtract} from 'app/icons';\nimport {t} from 'app/locale';\nimport space from 'app/styles/space';\nimport {Organization, Team} from 'app/types';\nimport useTeams from 'app/utils/useTeams';\nimport EmptyMessage from 'app/views/settings/components/emptyMessage';\n\ntype Props = {\n  organization: Organization;\n  /**\n   * Should button be disabled\n   */\n  disabled: boolean;\n  /**\n   * Teams that are already selected.\n   */\n  selectedTeams: Team[];\n  /**\n   * callback when teams are added\n   */\n  onAddTeam: (team: Team) => void;\n  /**\n   * Callback when teams are removed\n   */\n  onRemoveTeam: (teamSlug: string) => void;\n  /**\n   * Optional menu header.\n   */\n  menuHeader?: React.ReactElement;\n  /**\n   * Message to display when the last team is removed\n   * if empty no confirm will be displayed.\n   */\n  confirmLastTeamRemoveMessage?: string;\n  /**\n   * Used to determine whether we should show a loading state while waiting for teams\n   */\n  loadingTeams?: boolean;\n};\n\nfunction TeamSelect({\n  disabled,\n  selectedTeams,\n  menuHeader,\n  organization,\n  onAddTeam,\n  onRemoveTeam,\n  confirmLastTeamRemoveMessage,\n  loadingTeams,\n}: Props) {\n  const {teams, onSearch, fetching} = useTeams();\n\n  const handleAddTeam = (option: Item) => {\n    const team = teams.find(tm => tm.slug === option.value);\n    if (team) {\n      onAddTeam(team);\n    }\n  };\n\n  const renderBody = () => {\n    if (selectedTeams.length === 0) {\n      return <EmptyMessage>{t('No Teams assigned')}</EmptyMessage>;\n    }\n    const confirmMessage =\n      selectedTeams.length === 1 && confirmLastTeamRemoveMessage\n        ? confirmLastTeamRemoveMessage\n        : null;\n\n    return selectedTeams.map(team => (\n      <TeamRow\n        key={team.slug}\n        orgId={organization.slug}\n        team={team}\n        onRemove={slug => onRemoveTeam(slug)}\n        disabled={disabled}\n        confirmMessage={confirmMessage}\n      />\n    ));\n  };\n\n  // Only show options that aren't selected in the dropdown\n  const options = teams\n    .filter(team => !selectedTeams.some(selectedTeam => selectedTeam.slug === team.slug))\n    .map((team, index) => ({\n      index,\n      value: team.slug,\n      searchKey: team.slug,\n      label: <DropdownTeamBadge avatarSize={18} team={team} />,\n    }));\n\n  return (\n    <Panel>\n      <PanelHeader hasButtons>\n        {t('Team')}\n        <DropdownAutoComplete\n          items={options}\n          busyItemsStillVisible={fetching}\n          onChange={debounce<(e: React.ChangeEvent<HTMLInputElement>) => void>(\n            e => onSearch(e.target.value),\n            DEFAULT_DEBOUNCE_DURATION\n          )}\n          onSelect={handleAddTeam}\n          emptyMessage={t('No teams')}\n          menuHeader={menuHeader}\n          disabled={disabled}\n          alignMenu=\"right\"\n        >\n          {({isOpen}) => (\n            <DropdownButton\n              aria-label={t('Add Team')}\n              isOpen={isOpen}\n              size=\"xsmall\"\n              disabled={disabled}\n            >\n              {t('Add Team')}\n            </DropdownButton>\n          )}\n        </DropdownAutoComplete>\n      </PanelHeader>\n\n      <PanelBody>{loadingTeams ? <LoadingIndicator /> : renderBody()}</PanelBody>\n    </Panel>\n  );\n}\n\ntype TeamRowProps = {\n  orgId: string;\n  team: Team;\n  onRemove: Props['onRemoveTeam'];\n  disabled: boolean;\n  confirmMessage: string | null;\n};\n\nconst TeamRow = ({orgId, team, onRemove, disabled, confirmMessage}: TeamRowProps) => (\n  <TeamPanelItem>\n    <StyledLink to={`/settings/${orgId}/teams/${team.slug}/`}>\n      <TeamBadge team={team} />\n    </StyledLink>\n    <Confirm\n      message={confirmMessage}\n      bypass={!confirmMessage}\n      onConfirm={() => onRemove(team.slug)}\n      disabled={disabled}\n    >\n      <Button\n        size=\"xsmall\"\n        icon={<IconSubtract isCircled size=\"xs\" />}\n        disabled={disabled}\n      >\n        {t('Remove')}\n      </Button>\n    </Confirm>\n  </TeamPanelItem>\n);\n\nconst DropdownTeamBadge = styled(TeamBadge)`\n  font-weight: normal;\n  font-size: ${p => p.theme.fontSizeMedium};\n  text-transform: none;\n`;\n\nconst TeamPanelItem = styled(PanelItem)`\n  padding: ${space(2)};\n  align-items: center;\n`;\n\nconst StyledLink = styled(Link)`\n  flex: 1;\n  margin-right: ${space(1)};\n`;\n\nexport default TeamSelect;\n"],"names":["doCallback","params","name","args","callIfFunction","async","fetchUserTeams","api","teams","requestPromise","orgId","TeamActions","fetchTeamDetails","options","teamId","request","success","data","error","updateTeamSuccess","updateTeam","endpoint","method","joinTeam","memberId","id","uniqueId","leaveTeam","createTeam","team","then","addSuccessMessage","tct","slug","organization","err","addErrorMessage","removeTeam","isActiveSuperuser","isSuperuser","ConfigStore","Cookies","undefined","fetchTeams","slugs","search","limit","lastSearch","cursor","query","length","map","join","trim","per_page","hasMore","nextCursor","resp","includeAllArgs","pageLinks","getResponseHeader","paginationObject","parseLinkHeader","next","results","previous","provideUserTeams","useApi","useLegacyStore","OrganizationStore","store","TeamStore","storeSlugs","Set","t","slugsToLoad","filter","has","shouldLoadSlugs","shouldLoadTeams","loadedUserTeams","initiallyLoaded","state","setState","useState","fetching","fetchError","slugsRef","useRef","current","size","some","useEffect","fetchedTeams","uniqBy","console","loadTeamsBySlug","loadUserTeams","includes","isMember","loading","onSearch","clear","AsyncView","AsyncComponent","getTitle","render","title","this","renderComponent","TeamBadgeContainer","React","props","onTeamStoreUpdate","UNSAFE_componentWillReceiveProps","nextProps","isEqual","componentWillUnmount","unlistener","updatedTeam","avatar","TeamSelect","disabled","selectedTeams","menuHeader","onAddTeam","onRemoveTeam","confirmLastTeamRemoveMessage","loadingTeams","useTeams","selectedTeam","index","value","searchKey","label","DropdownTeamBadge","avatarSize","hasButtons","items","busyItemsStillVisible","onChange","debounce","e","target","DEFAULT_DEBOUNCE_DURATION","onSelect","option","find","tm","emptyMessage","alignMenu","isOpen","confirmMessage","TeamRow","onRemove","renderBody","TeamPanelItem","StyledLink","to","message","bypass","onConfirm","icon","isCircled","TeamBadge","p","theme","fontSizeMedium","PanelItem","space","Link"],"sourceRoot":""}