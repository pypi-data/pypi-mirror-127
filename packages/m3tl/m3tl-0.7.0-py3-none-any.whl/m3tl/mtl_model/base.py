# AUTOGENERATED! DO NOT EDIT! File to edit: source_nbs/15-00_mtl_model_base.ipynb (unless otherwise specified).

__all__ = ['MTLBase', 'BasicMTL']

# Cell
from copy import copy
from typing import Dict, Tuple

import tensorflow as tf
from ..utils import dispatch_features, get_phase


class MTLBase(tf.keras.Model):
    def __init__(self, params, name:str, *args, **kwargs):
        super(MTLBase, self).__init__(name, *args, **kwargs)
        self.params = params
        self.available_extract_target = copy(self.params.problem_list)
        self.available_extract_target.append('all')
        self.problem_list = self.params.problem_list

    def extract_feature(self, extract_problem: str, feature_dict: dict, hidden_feature_dict: dict):

        mode = get_phase()
        if extract_problem not in self.available_extract_target:
            raise ValueError('Tried to extract feature {0}, available extract problem: {1}'.format(
                extract_problem, self.available_extract_target))

        # if key contains problem, return directly
        if extract_problem in feature_dict and extract_problem in hidden_feature_dict:
            return feature_dict[extract_problem], hidden_feature_dict[extract_problem]

        # use dispatch function to extract record based on loss multiplier
        if 'all' in feature_dict and 'all' in hidden_feature_dict:
            return dispatch_features(
                features=feature_dict['all'], hidden_feature=hidden_feature_dict['all'],
                problem=extract_problem, mode=mode)
        return dispatch_features(
                features=feature_dict, hidden_feature=hidden_feature_dict,
                problem=extract_problem, mode=mode)

    def call(self, inputs: Tuple[Dict[str, tf.Tensor]]):
        raise NotImplementedError


# Cell
class BasicMTL(MTLBase):
    def __init__(self, params, name: str, *args, **kwargs):
        super().__init__(params, name, *args, **kwargs)

    def call(self, inputs: Tuple[Dict[str, tf.Tensor]]):
        mode = get_phase()
        features, hidden_features = inputs
        features_per_problem, hidden_features_per_problem = {}, {}
        for problem in self.available_extract_target:
            features_per_problem[problem], hidden_features_per_problem[problem] = self.extract_feature(
                extract_problem=problem, feature_dict=features, hidden_feature_dict=hidden_features
            )
        return features_per_problem, hidden_features_per_problem