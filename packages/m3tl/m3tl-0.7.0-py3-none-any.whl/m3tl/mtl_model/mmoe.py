# AUTOGENERATED! DO NOT EDIT! File to edit: source_nbs/15-01_mtl_model_mmoe.ipynb (unless otherwise specified).

__all__ = ['MMoE']

# Cell
from typing import Dict, Tuple

import tensorflow as tf
from ..base_params import BaseParams
from .base import MTLBase
from ..utils import get_phase


class MMoE(MTLBase):
    def __init__(self, params: BaseParams, name:str):
        super(MMoE, self).__init__(params, name)
        self.num_experts = self.params.get('num_experts', 8)
        self.num_experts_units = self.params.get('num_experts_units', 128)
        self.problem_list = self.params.problem_list
        self.gate_dict = {
            problem: tf.keras.layers.Dense(self.num_experts, activation='softmax') for problem in self.problem_list
        }

    def build(self, input_shape):
        features_input_shape, hidden_feature_input_shape = input_shape
        pooled_shape = hidden_feature_input_shape['all']['pooled']
        self.experts_kernel = self.add_weight(
            name='experts_kernel',
            shape=(pooled_shape[-1], self.num_experts_units, self.num_experts)
        )
        # add leading dims to support braodcasting
        self.experts_bias = self.add_weight(
            name='experts_bias',
            shape=(1, 1, self.num_experts_units, self.num_experts)
        )

    def call(self, inputs: Tuple[Dict[str, tf.Tensor]]):
        mode = get_phase()
        features, hidden_features = inputs
        all_features, all_hidden_features = self.extract_feature('all', feature_dict=features, hidden_feature_dict=hidden_features)

        # get seq outputs
        # [batch_size, seq_len, hidden_size]
        seq_hidden = all_hidden_features['seq']
        # [batch_size, seq_len, num_expert_units, num_experts]
        experts_outputs = tf.tensordot(seq_hidden, self.experts_kernel, axes=[2, 0]) + self.experts_bias

        experts_output_dict = {
            'pooled': experts_outputs[:, 0, :, :],
            'seq': experts_outputs
        }

        # per problem gating
        # we can save a little bit of computation by extract per problem features first
        features_per_problem, hidden_features_per_problem = {}, {}
        for problem, gate_net in self.gate_dict.items():
            features_per_problem[problem], problem_experts_output = self.extract_feature(
                extract_problem=problem, feature_dict=all_features, hidden_feature_dict=experts_output_dict
            )
            _, problem_hidden_features = self.extract_feature(
                extract_problem=problem, feature_dict=all_features, hidden_feature_dict=all_hidden_features
            )

            # apply gating
            # [problem_batch_size, seq_len, 1, num_experts]
            experts_weight = gate_net(problem_hidden_features['seq'])
            experts_weight = tf.expand_dims(experts_weight, axis=2)
            # [problem_batch_size, seq_len, num_expert_units, num_experts]
            expert_output_per_problem = problem_experts_output['seq']

            # [problem_batch_size, seq_len, num_expert_units]
            gated_experts_output = tf.reduce_mean(experts_weight*expert_output_per_problem, axis=-1)
            hidden_features_per_problem[problem] = {
                'pooled': gated_experts_output[:, 0, :],
                'seq': gated_experts_output
            }

        return features_per_problem, hidden_features_per_problem
