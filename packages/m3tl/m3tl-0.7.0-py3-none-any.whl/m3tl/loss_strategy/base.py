# AUTOGENERATED! DO NOT EDIT! File to edit: source_nbs/16-00_loss_combination_strategy.ipynb (unless otherwise specified).

__all__ = ['LossCombinationStrategyBase', 'SumLossCombination']

# Cell
from collections import deque
from typing import Dict, List

import tensorflow as tf
from ..utils import get_phase
from tensorflow.python.util.nest import (flatten,
                                         flatten_with_joined_string_paths)


class LossCombinationStrategyBase(tf.keras.Model):
    def __init__(self, params, name:str, *args, **kwargs):
        super(LossCombinationStrategyBase, self).__init__(name, *args, **kwargs)
        self.params = params
        self.problem_list = self.params.problem_list
        self.hist_loss_dict = deque(maxlen=100)
        self.hist_metric_dict = deque(maxlen=100)

    def extract_loss_metric_dict_from_history(self,
                                            history: tf.keras.callbacks.History,
                                            structure: dict,
                                            prefix='val_') -> dict:
        history: Dict[str, float] = history.history

        # metrics from validation set starts with val
        if prefix:
            if prefix != 'val_':
                raise ValueError('prefix should either be "val_" or None')
            history = {k.replace(prefix, ''): v for k, v in history.items() if k.startswith(prefix)}



        # get structure path
        structure_path = [p for p, _ in flatten_with_joined_string_paths(structure)]
        # make flat history and pack
        flat_history = [history[p] for p in structure_path]
        history = tf.nest.pack_sequence_as(structure=structure, flat_sequence=flat_history)

        return history

    def get_all_losses(self, current_loss_dict: dict) -> List[tf.Tensor]:
        return flatten(current_loss_dict)

    def get_problem_loss(self, current_loss_dict:dict, problem: str) -> List[tf.Tensor]:
        flatten_loss_with_path = flatten_with_joined_string_paths(current_loss_dict)
        return [v for p, v in flatten_loss_with_path if problem in p]

    def call(self,
            current_loss_dict: dict,
            current_metric_dict: dict,
            history: tf.keras.callbacks.History):
        raise NotImplementedError


# Cell
class SumLossCombination(LossCombinationStrategyBase):
    def __init__(self, params, name: str, *args, **kwargs):
        super().__init__(params, name, *args, **kwargs)

    def call(self,
            current_loss_dict: dict,
            current_metric_dict: dict,
            history: tf.keras.callbacks.History):
        mode = get_phase()
        # total losses
        losses = self.get_all_losses(current_loss_dict)
        return losses