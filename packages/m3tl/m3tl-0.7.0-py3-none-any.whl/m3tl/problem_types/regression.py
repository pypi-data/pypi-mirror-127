# AUTOGENERATED! DO NOT EDIT! File to edit: source_nbs/12_7_problem_type_regression.ipynb (unless otherwise specified).

__all__ = ['mse_wrapper', 'Regression', 'regression_get_or_make_label_encoder_fn', 'regression_label_handling_fn']

# Cell
from typing import Dict, List, Tuple

import numpy as np
import tensorflow as tf
from ..base_params import BaseParams
from .utils import (empty_tensor_handling_loss,
                                      nan_loss_handling)
from ..special_tokens import PREDICT, TRAIN
from ..utils import get_phase, variable_summaries


# Cell

def mse_wrapper(labels, logits, from_logits=True):
    return tf.keras.losses.mean_squared_error(labels, logits)


class Regression(tf.keras.Model):
    def __init__(self, params: BaseParams, problem_name: str) -> None:
        super(Regression, self).__init__(name=problem_name)
        self.params = params
        self.problem_name = problem_name
        self.num_classes = 1
        self.dense = tf.keras.layers.Dense(self.num_classes)

    def call(self, inputs: Tuple[Dict]):
        mode = get_phase()
        feature, hidden_feature = inputs
        pooled_hidden = hidden_feature['pooled']

        logits = self.dense(pooled_hidden)
        if self.params.detail_log:
            for weight_variable in self.weights:
                variable_summaries(weight_variable, self.problem_name)

        if mode != PREDICT:
            # this is actually a float
            label = feature['{}_label_ids'.format(self.problem_name)]

            loss = empty_tensor_handling_loss(label, logits, mse_wrapper)
            loss = nan_loss_handling(loss)
            self.add_loss(loss)

            self.add_metric(tf.math.negative(
                loss), name='{}_neg_mse'.format(self.problem_name), aggregation='mean')
        return logits

# Cell
def regression_get_or_make_label_encoder_fn(params: BaseParams, problem: str, mode: str, label_list: List[str], *args, **kwargs):
    if mode == TRAIN:
        # set params num_classes for this problem
        params.set_problem_info(problem=problem, info_name='num_classes', info=1)
    return None


# Cell
def regression_label_handling_fn(target, label_encoder=None, tokenizer=None, decoding_length=None, *args, **kwargs):
    # return label_id and label mask
    label_id = float(target)
    return label_id, None

