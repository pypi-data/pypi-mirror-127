# AUTOGENERATED! DO NOT EDIT! File to edit: source_nbs/12_8_problem_type_vector_fit.ipynb (unless otherwise specified).

__all__ = ['cosine_wrapper', 'VectorFit', 'vector_fit_get_or_make_label_encoder_fn', 'vector_fit_label_handling_fn']

# Cell
from typing import Dict, Tuple

import numpy as np
import tensorflow as tf
from ..base_params import BaseParams
from .utils import (empty_tensor_handling_loss,
                                      nan_loss_handling)
from ..special_tokens import PREDICT
from ..utils import get_phase


# Cell
def cosine_wrapper(labels, logits, from_logits=True):
    return tf.keras.losses.cosine_similarity(labels, logits)


class VectorFit(tf.keras.Model):
    def __init__(self, params: BaseParams, problem_name: str) -> None:
        super(VectorFit, self).__init__(name=problem_name)
        self.params = params
        self.problem_name = problem_name
        self.num_classes = self.params.get_problem_info(problem=problem_name, info_name='num_classes')
        self.dense = tf.keras.layers.Dense(self.num_classes)

    def call(self, inputs: Tuple[Dict]):
        mode = get_phase()
        feature, hidden_feature = inputs
        pooled_hidden = hidden_feature['pooled']

        logits = self.dense(pooled_hidden)
        if mode != PREDICT:
            # this is actually a vector
            label = feature['{}_label_ids'.format(self.problem_name)]

            loss = empty_tensor_handling_loss(label, logits, cosine_wrapper)
            loss = nan_loss_handling(loss)
            self.add_loss(loss)

            self.add_metric(tf.math.negative(
                loss), name='{}_cos_sim'.format(self.problem_name), aggregation='mean')
        return logits

# Cell
def vector_fit_get_or_make_label_encoder_fn(params: BaseParams, problem, mode, label_list, *args, **kwargs):
    if label_list:
        # set params num_classes for this problem
        label_array = np.array(label_list)
        params.set_problem_info(problem=problem, info_name='num_classes', info=label_array.shape[-1])
    return None


# Cell
def vector_fit_label_handling_fn(target, label_encoder=None, tokenizer=None, decoding_length=None, *args, **kwargs):
    # return label_id and label mask
    label_id = np.array(target, dtype='float32')
    return label_id, None

