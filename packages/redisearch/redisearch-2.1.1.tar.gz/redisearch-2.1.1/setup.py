# -*- coding: utf-8 -*-
from setuptools import setup

packages = \
['redisearch']

package_data = \
{'': ['*']}

install_requires = \
['redis==3.5.3', 'rejson>=0.5.4,<0.6.0', 'six>=1.16.0,<2.0.0']

extras_require = \
{':python_version >= "3.6" and python_version < "4.0"': ['hiredis>=2.0.0,<3.0.0']}

setup_kwargs = {
    'name': 'redisearch',
    'version': '2.1.1',
    'description': 'RedisSearch Python Client',
    'long_description': '[![license](https://img.shields.io/github/license/RediSearch/redisearch-py.svg)](https://github.com/RediSearch/redisearch-py/blob/master/LICENSE)\n[![PyPI version](https://badge.fury.io/py/redisearch.svg)](https://badge.fury.io/py/redisearch)\n[![CircleCI](https://circleci.com/gh/RediSearch/redisearch-py/tree/master.svg?style=svg)](https://circleci.com/gh/RediSearch/redisearch-py/tree/master)\n[![GitHub issues](https://img.shields.io/github/release/RediSearch/redisearch-py.svg)](https://github.com/RediSearch/redisearch-py/releases/latest)\n[![Codecov](https://codecov.io/gh/RediSearch/redisearch-py/branch/master/graph/badge.svg)](https://codecov.io/gh/RediSearch/redisearch-py)\n[![Known Vulnerabilities](https://snyk.io/test/github/RediSearch/redisearch-py/badge.svg?targetFile=pyproject.toml)](https://snyk.io/test/github/RediSearch/redisearch-py?targetFile=pyproject.toml)\n[![Total alerts](https://img.shields.io/lgtm/alerts/g/RediSearch/redisearch-py.svg?logo=lgtm&logoWidth=18)](https://lgtm.com/projects/g/RediSearch/redisearch-py/alerts/)\n\n# RediSearch Python Client\n[![Forum](https://img.shields.io/badge/Forum-RediSearch-blue)](https://forum.redislabs.com/c/modules/redisearch/)\n[![Discord](https://img.shields.io/discord/697882427875393627?style=flat-square)](https://discord.gg/xTbqgTB)\n\n## Deprecation notice\n\nAs of [redis-py 4.0.0](https://pypi.org/project/redis/4.0.0) this library is deprecated. It\'s features have been merged into redis-py. Please either install it [from pypy](https://pypi.org/project/redis) or [the repo](https://github.com/redis/redis-py).\n\n--------------------------------\n\nThis is a Python search engine library that utilizes the [RediSearch Redis Module](http://redisearch.io) API.\n\nIt is the "official" client of RediSearch, and should be regarded as its canonical client implementation.\n\n## Features\n\nRediSearch is a source avaliable ([RSAL](https://raw.githubusercontent.com/RediSearch/RediSearch/master/LICENSE)), high performance search engine implemented as a [Redis Module](https://redis.io/topics/modules-intro).\nIt uses custom data types to allow fast, stable and feature rich full-text search inside Redis.\n\nThis client is a wrapper around the RediSearch API protocol, that allows you to utilize its features easily.\n\n### RediSearch\'s features include:\n\n* Full-Text indexing of multiple fields in documents.\n* Incremental indexing without performance loss.\n* Document ranking (provided manually by the user at index time) and field weights.\n* Auto-complete suggestions (with fuzzy prefix suggestions).\n* Exact Phrase Search.\n* Stemming based query expansion in [many languages](http://redisearch.io/Stemming/) (using [Snowball](http://snowballstem.org/)).\n* Limiting searches to specific document fields (up to 8 fields supported).\n* Numeric filters and ranges.\n* Automatically index existing HASH keys as documents.\n\nFor more details, visit [http://redisearch.io](http://redisearch.io)\n\n## Examples\n\n### Creating a client instance\n\nWhen you create a redisearch-py client instance, the only required argument\nis the name of the index.\n\n```py\nfrom redisearch import Client\n\nclient = Client("my-index")\n```\n\nTo connect with a username and/or password, pass those options to the client\ninitializer.\n\n```py\nclient = Client("my-index", password="my-password")\n```\n\n### Using core Redis commands\n\nEvery instance of `Client` contains an instance of the redis-py `Client` as\nwell. Use this object to run core Redis commands.\n\n```py\nimport datetime\n\nfrom redisearch import Client\n\nSTART_TIME = datetime.datetime.now().strftime("%Y-%m-%d-%H:%M.%S")\n\nclient = Client("my-index")\n\nclient.redis.set("start-time", START_TIME)\n```\n\n### Checking if a RediSearch index exists\n\nTo check if a RediSearch index exists, use the `FT.INFO` command and catch\nthe `ResponseError` raised if the index does not exist.\n\n```py\nfrom redis import ResponseError\nfrom redisearch import Client\n\nclient = Client("my-index")\n\ntry:\n    client.info()\nexcept ResponseError:\n    # Index does not exist. We need to create it!\n```\n\n### Defining a search index\n\nUse an instance of `IndexDefinition` to define a search index. You only need\nto do this when you create an index.\n\nRediSearch indexes follow Hashes in your Redis databases by watching *key\nprefixes*. If a Hash whose key starts with one of the search index\'s\nconfigured key prefixes is added, updated, or deleted from Redis, RediSearch\nwill make those changes in the index. You configure a search index\'s key\nprefixes using the `prefix` parameter of the `IndexDefinition` initializer.\n\n**NOTE**: Once you create an index, RediSearch will continuously index these\nkeys when their Hashes change.\n\n`IndexDefinition` also takes a *schema*. The schema specifies which fields to\nindex from within the Hashes that the index follows. The field types are:\n\n* TextField\n* TagField\n* NumericField\n* GeoField\n\nFor more information on what these field types mean, consult the [RediSearch\ndocumentation](https://oss.redislabs.com/redisearch/Commands/#ftcreate) on\nthe `FT.CREATE` command.\n\nWith redisearch-py, the schema is an iterable of `Field` instances. Once you\nhave an `IndexDefinition` instance, you can create the instance by passing a\nschema iterable to the `create_index()` method.\n\n```py\nfrom redis import ResponseError\nfrom redisearch import Client, IndexDefinition, TextField\n\nSCHEMA = (\n    TextField("title", weight=5.0),\n    TextField("body")\n)\n\nclient = Client("my-index")\n\ndefinition = IndexDefinition(prefix=[\'blog:\'])\n\ntry:\n    client.info()\nexcept ResponseError:\n    # Index does not exist. We need to create it!\n    client.create_index(SCHEMA, definition=definition)\n```\n\n### Indexing a document\n\nA RediSearch 2.0 index continually follows Hashes with the key prefixes you\ndefined, so if you want to add a document to the index, you only need to\ncreate a Hash with one of those prefixes.\n\n```py\n# Indexing a document with RediSearch 2.0.\ndoc = {\n    \'title\': \'RediSearch\',\n    \'body\': \'Redisearch adds querying, indexing, and full-text search to Redis\'\n}\nclient.redis.hset(\'doc:1\', mapping=doc)\n```\n\nPast versions of RediSearch required that you call the `add_document()`\nmethod. This method is deprecated, but we include its usage here for\nreference.\n\n```py\n# Indexing a document for RediSearch 1.x\nclient.add_document(\n    "doc:2",\n    title="RediSearch",\n    body="Redisearch implements a search engine on top of redis",\n)\n```\n\n### Querying\n\n#### Basic queries\n\nUse the `search()` method to perform basic full-text and field-specific\nsearches. This method doesn\'t take many of the options available to the\nRediSearch `FT.SEARCH` command -- read the section on building complex\nqueries later in this document for information on how to use those.\n\n```py\nres = client.search("evil wizards")\n```\n#### Result objects\n\nResults are wrapped in a `Result` object that includes the number of results\nand a list of matching documents.\n\n```py\n>>> print(res.total)\n2\n>>> print(res.docs[0].title)\n"Wizard Story 2: Evil Wizards Strike Back"\n```\n\n#### Building complex queries\n\nYou can use the `Query` object to build complex queries:\n\n```py\nq = Query("evil wizards").verbatim().no_content().with_scores().paging(0, 5)\nres = client.search(q)\n```\n\n For an explanation of these options, see the [RediSearch\n documentation](https://oss.redislabs.com/redisearch/Commands/#ftsearch) for\n the `FT.SEARCH` command.\n\n#### Query syntax\n\nThe default behavior of queries is to run a full-text search across all\n`TEXT` fields in the index for the intersection of all terms in the query.\n\nSo the example given in the "Basic queries" section of this README,\n`client.search("evil wizards")`, run a full-text search for the intersection\nof "evil" and "wizard" in all `TEXT` fields.\n\nMany more types of queries are possible, however! The string you pass into\nthe `search()` method or `Query()` initializer has the full range of query\nsyntax available in RediSearch.\n\nFor example, a full-text search against a specific `TEXT` field in the index\nlooks like this:\n\n```py\n# Full-text search\nres = client.search("@title:evil wizards")\n```\n\nFinding books published in 2020 or 2021 looks like this:\n\n```python\nclient.search("@published_year:[2020 2021]")\n```\n\nTo learn more, see the [RediSearch\ndocumentation](https://oss.redislabs.com/redisearch/Query_Syntax/) on query\nsyntax.\n\n### Aggregations\n\nThis library contains a programmatic interface to run [aggregation\nqueries](https://oss.redislabs.com/redisearch/Aggregations/) with RediSearch.\n\n#### Making an aggregation query\n\nTo make an aggregation query, pass an instance of the `AggregateRequest`\nclass to the `search()` method of an instance of `Client`.\n\nFor example, here is what finding the most books published in a single year\nlooks like:\n\n```py\nfrom redisearch import Client\nfrom redisearch import reducers\nfrom redisearch.aggregation import AggregateRequest\n\nclient = Client(\'books-idx\')\n\nrequest = AggregateRequest(\'*\').group_by(\n    \'@published_year\', reducers.count().alias("num_published")\n).group_by(\n    [], reducers.max("@num_published").alias("max_books_published_per_year")\n)\n\nresult = client.aggregate(request)\n```\n\n#### A redis-cli equivalent query\n\nThe aggregation query just given is equivalent to the following\n`FT.AGGREGATE` command entered directly into the redis-cli:\n\n```sql\nFT.AGGREGATE books-idx *\n    GROUPBY 1 @published_year\n      REDUCE COUNT 0 AS num_published\n    GROUPBY 0\n      REDUCE MAX 1 @num_published AS max_books_published_per_year\n```\n\n#### The AggregateResult object\n\nAggregation queries return an `AggregateResult` object that contains the rows\nreturned for the query and a cursor if you\'re using the [cursor\nAPI](https://oss.redislabs.com/redisearch/Aggregations/#cursor_api).\n\n```py\nfrom redisearch.aggregation import AggregateRequest, Asc\n\nrequest = AggregateRequest(\'*\').group_by(\n    [\'@published_year\'], reducers.avg(\'average_rating\').alias(\'average_rating_for_year\')\n).sort_by(\n    Asc(\'@average_rating_for_year\')\n).limit(\n    0, 10\n).filter(\'@published_year > 0\')\n\n...\n\n\nIn [53]: resp = c.aggregate(request)\nIn [54]: resp.rows\nOut[54]:\n[[\'published_year\', \'1914\', \'average_rating_for_year\', \'0\'],\n [\'published_year\', \'2009\', \'average_rating_for_year\', \'1.39166666667\'],\n [\'published_year\', \'2011\', \'average_rating_for_year\', \'2.046\'],\n [\'published_year\', \'2010\', \'average_rating_for_year\', \'3.125\'],\n [\'published_year\', \'2012\', \'average_rating_for_year\', \'3.41\'],\n [\'published_year\', \'1967\', \'average_rating_for_year\', \'3.603\'],\n [\'published_year\', \'1970\', \'average_rating_for_year\', \'3.71875\'],\n [\'published_year\', \'1966\', \'average_rating_for_year\', \'3.72666666667\'],\n [\'published_year\', \'1927\', \'average_rating_for_year\', \'3.77\']]\n```\n\n#### Reducer functions\n\nNotice from the example that we used an object from the `reducers` module.\nSee the [RediSearch documentation](https://oss.redislabs.com/redisearch/Aggregations/#groupby_reducers)\nfor more examples of reducer functions you can use when grouping results.\n\nReducer functions include an `alias()` method that gives the result of the\nreducer a specific name. If you don\'t supply a name, RediSearch will generate\none.\n\n#### Grouping by zero, one, or multiple fields\n\nThe `group_by` statement can take a single field name as a string, or multiple\nfield names as a list of strings.\n\n```py\nAggregateRequest(\'*\').group_by(\'@published_year\', reducers.count())\n\nAggregateRequest(\'*\').group_by(\n    [\'@published_year\', \'@average_rating\'],\n    reducers.count())\n```\n\nTo run a reducer function on every result from an aggregation query, pass an\nempty list to `group_by()`, which is equivalent to passing the option\n`GROUPBY 0` when writing an aggregation in the redis-cli.\n\n```py\nAggregateRequest(\'*\').group_by([], reducers.max("@num_published"))\n```\n\n**NOTE**: Aggregation queries require at least one `group_by()` method call.\n\n#### Sorting and limiting\n\nUsing an `AggregateRequest` instance, you can sort with the `sort_by()` method\nand limit with the `limit()` method.\n\nFor example, finding the average rating of books published each year, sorting\nby the average rating for the year, and returning only the first ten results:\n\n```py\nfrom redisearch import Client\nfrom redisearch.aggregation import AggregateRequest, Asc\n\nc = Client()\n\nrequest = AggregateRequest(\'*\').group_by(\n    [\'@published_year\'], reducers.avg(\'average_rating\').alias(\'average_rating_for_year\')\n).sort_by(\n    Asc(\'@average_rating_for_year\')\n).limit(0, 10)\n\nc.aggregate(request)\n```\n\n**NOTE**: The first option to `limit()` is a zero-based offset, and the second\noption is the number of results to return.\n\n#### Filtering\n\nUse filtering to reject results of an aggregation query after your reducer\nfunctions run. For example, calculating the average rating of books published\neach year and only returning years with an average rating higher than 3:\n\n```py\nfrom redisearch.aggregation import AggregateRequest, Asc\n\nreq = AggregateRequest(\'*\').group_by(\n    [\'@published_year\'], reducers.avg(\'average_rating\').alias(\'average_rating_for_year\')\n).sort_by(\n    Asc(\'@average_rating_for_year\')\n).filter(\'@average_rating_for_year > 3\')\n```\n\n## Installing\n\n1. [Install RediSearch](http://redisearch.io/Quick_Start)\n2. Install the Python client:\n\n```sh\n$ pip install redisearch\n```\n\n## Developing\n\n1. Create a virtualenv to manage your python dependencies, and ensure it\'s active.\n   ```virtualenv -v venv```\n2. Install [pypoetry](https://python-poetry.org/) to manage your dependencies.\n   ```pip install --user poetry```\n3. Install dependencies.\n   ```poetry install```\n\nNote: Due to an [interaction between](https://github.com/python-poetry/poetry/issues/4210) and python 3.10, you *may* need to run the following, if you receive a JSONError while installing packages.\n```\npoetry config experimental.new-installer false\n```\n\n## Testing\n\nTesting can easily be performed using using Docker.\nRun the following:\n\n```\nmake -C test/docker test PYTHON_VER=3\n```\n\n(Replace `PYTHON_VER=3` with `PYTHON_VER=2` to test with Python 2.7.)\n\nAlternatively, use the following procedure:\n\nFirst, run:\n\n```\nPYTHON_VER=3 ./test/test-setup.sh\n```\n\nThis will set up a Python virtual environment in `venv3` (or in `venv2` if `PYTHON_VER=2` is used).\n\nAfterwards, run RediSearch in a container as a daemon:\n\n```\ndocker run -d -p 6379:6379 redislabs/redisearch:2.0.0\n```\n\nFinally, invoke the virtual environment and run the tests:\n\n```\n. ./venv3/bin/activate\nREDIS_PORT=6379 python test/test.py\nREDIS_PORT=6379 python test/test_builder.py\n```\n',
    'author': 'RedisLabs',
    'author_email': 'oss@redislabs.com',
    'maintainer': None,
    'maintainer_email': None,
    'url': None,
    'packages': packages,
    'package_data': package_data,
    'install_requires': install_requires,
    'extras_require': extras_require,
    'python_requires': '>=3.6.0,<4.0.0',
}


setup(**setup_kwargs)
